/*
 * This file was automatically generated by EvoSuite
 * Fri Dec 12 05:26:39 GMT 2014
 */

package com.google.javascript.jscomp;

import static org.junit.Assert.*;
import org.junit.Test;
import com.google.javascript.jscomp.Tracer;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
 import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.mock.java.lang.MockIllegalStateException;
import org.junit.runner.RunWith;

 
public class TracerEvoSuite_branch_Test   {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Tracer.AtomicTracerStatMap tracer_AtomicTracerStatMap0 = new Tracer.AtomicTracerStatMap();
      assertNotNull(tracer_AtomicTracerStatMap0);
      
      Tracer.InternalClock tracer_InternalClock0 = Tracer.clock;
      assertNotNull(tracer_InternalClock0);
      
      long long0 = tracer_InternalClock0.currentTimeMillis();
      assertEquals(1392409281320L, long0);
      
      String string0 = "tY[$aovDQ*HJ7p<8R:i";
      tracer_AtomicTracerStatMap0.incrementBy(string0, long0);
      tracer_AtomicTracerStatMap0.incrementBy(string0, long0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Tracer.InternalClock tracer_InternalClock0 = Tracer.clock;
      assertNotNull(tracer_InternalClock0);
      
      Tracer.ThreadTrace tracer_ThreadTrace0 = Tracer.getThreadTrace();
      assertNotNull(tracer_ThreadTrace0);
      
      boolean boolean0 = tracer_ThreadTrace0.isEmpty();
      assertTrue(boolean0);
      
      tracer_ThreadTrace0.truncateEvents();
      tracer_ThreadTrace0.truncateOutstandingEvents();
      String string0 = "/-*mw_K_9n\\";
      Tracer tracer0 = Tracer.shortName(tracer_ThreadTrace0, string0);
      assertNotNull(tracer0);
      
      Tracer.ThreadTrace tracer_ThreadTrace1 = new Tracer.ThreadTrace();
      assertNotSame(tracer_ThreadTrace1, tracer_ThreadTrace0);
      assertNotNull(tracer_ThreadTrace1);
      assertFalse(tracer_ThreadTrace1.equals((Object)tracer_ThreadTrace0));
      
      tracer_ThreadTrace1.truncateOutstandingEvents();
      assertNotSame(tracer_ThreadTrace1, tracer_ThreadTrace0);
      assertFalse(tracer_ThreadTrace1.equals((Object)tracer_ThreadTrace0));
      
      Tracer.ThreadTrace tracer_ThreadTrace2 = Tracer.getThreadTrace();
      assertSame(tracer_ThreadTrace2, tracer_ThreadTrace0);
      assertNotSame(tracer_ThreadTrace2, tracer_ThreadTrace1);
      assertNotNull(tracer_ThreadTrace2);
      assertFalse(tracer_ThreadTrace2.equals((Object)tracer_ThreadTrace1));
      
      tracer_ThreadTrace2.init();
      assertSame(tracer_ThreadTrace2, tracer_ThreadTrace0);
      assertNotSame(tracer_ThreadTrace2, tracer_ThreadTrace1);
      assertFalse(tracer_ThreadTrace2.equals((Object)tracer_ThreadTrace1));
      
      Tracer tracer1 = Tracer.shortName(tracer_ThreadTrace2, string0);
      assertNotSame(tracer1, tracer0);
      assertSame(tracer_ThreadTrace2, tracer_ThreadTrace0);
      assertNotSame(tracer_ThreadTrace2, tracer_ThreadTrace1);
      assertNotNull(tracer1);
      assertFalse(tracer1.equals((Object)tracer0));
      assertFalse(tracer_ThreadTrace2.equals((Object)tracer_ThreadTrace1));
      
      String string1 = Tracer.getCurrentThreadTraceReport();
      assertNotSame(string1, string0);
      assertEquals("      21.320 Start        [ThreadTrace] /-*mw_K_9n\\\n Unstopped timers:\n  [ThreadTrace] /-*mw_K_9n\\ (0 ms, started at 21.320)\n", string1);
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      
      int int0 = (-1);
      tracer_ThreadTrace2.endEvent(tracer0, int0);
      assertSame(tracer_ThreadTrace2, tracer_ThreadTrace0);
      assertNotSame(tracer_ThreadTrace2, tracer_ThreadTrace1);
      assertNotSame(tracer0, tracer1);
      assertNotSame(string0, string1);
      assertNotSame(tracer_ThreadTrace0, tracer_ThreadTrace1);
      assertSame(tracer_ThreadTrace0, tracer_ThreadTrace2);
      assertFalse(tracer_ThreadTrace2.equals((Object)tracer_ThreadTrace1));
      assertFalse(tracer0.equals((Object)tracer1));
      assertFalse(string0.equals((Object)string1));
      assertFalse(tracer_ThreadTrace0.equals((Object)tracer_ThreadTrace1));
      
      Tracer.logAndClearCurrentThreadTrace();
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      String string0 = "end idex";
      Tracer tracer0 = new Tracer(string0);
      //  // Unstable assertion: assertNotNull(tracer0);
      
      Tracer.enableTypeMaps();
      Tracer.ThreadTrace tracer_ThreadTrace0 = Tracer.getThreadTrace();
      //  // Unstable assertion: assertNotNull(tracer_ThreadTrace0);
      
      int int0 = 0;
      long long0 = tracer0.stop(int0);
      //  // Unstable assertion: assertEquals(0L, long0);
      
      Tracer tracer1 = Tracer.shortName(tracer0, string0);
      //  // Unstable assertion: assertNotSame(tracer1, tracer0);
      //  // Unstable assertion: assertNotSame(tracer0, tracer1);
      //  // Unstable assertion: assertNotNull(tracer1);
      //  // Unstable assertion: assertFalse(tracer1.equals((Object)tracer0));
      //  // Unstable assertion: assertFalse(tracer0.equals((Object)tracer1));
      
      // Undeclared exception!
      try {
        tracer_ThreadTrace0.endEvent(tracer1, int0);
       //  fail("Expecting exception: IllegalStateException");
       // Unstable assertion
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
      
      //  // Unstable assertion: assertNotSame(tracer1, tracer0);
      //  // Unstable assertion: assertNotSame(tracer0, tracer1);
      //  // Unstable assertion: assertFalse(tracer1.equals((Object)tracer0));
      //  // Unstable assertion: assertFalse(tracer0.equals((Object)tracer1));
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Tracer.InternalClock tracer_InternalClock0 = Tracer.clock;
      //  // Unstable assertion: assertNotNull(tracer_InternalClock0);
      
      Tracer.ThreadTrace tracer_ThreadTrace0 = Tracer.getThreadTrace();
      //  // Unstable assertion: assertNotNull(tracer_ThreadTrace0);
      
      boolean boolean0 = tracer_ThreadTrace0.isEmpty();
      //  // Unstable assertion: assertFalse(boolean0);
      
      tracer_ThreadTrace0.truncateEvents();
      tracer_ThreadTrace0.truncateOutstandingEvents();
      String string0 = "/-*mw_K_9n\\";
      Tracer tracer0 = Tracer.shortName(tracer_ThreadTrace0, string0);
      //  // Unstable assertion: assertNotNull(tracer0);
      
      Tracer.ThreadTrace tracer_ThreadTrace1 = new Tracer.ThreadTrace();
      //  // Unstable assertion: assertNotSame(tracer_ThreadTrace1, tracer_ThreadTrace0);
      //  // Unstable assertion: assertNotNull(tracer_ThreadTrace1);
      //  // Unstable assertion: assertFalse(tracer_ThreadTrace1.equals((Object)tracer_ThreadTrace0));
      
      tracer_ThreadTrace1.truncateOutstandingEvents();
      //  // Unstable assertion: assertNotSame(tracer_ThreadTrace1, tracer_ThreadTrace0);
      //  // Unstable assertion: assertFalse(tracer_ThreadTrace1.equals((Object)tracer_ThreadTrace0));
      
      Tracer.ThreadTrace tracer_ThreadTrace2 = Tracer.getThreadTrace();
      //  // Unstable assertion: assertNotSame(tracer_ThreadTrace2, tracer_ThreadTrace1);
      //  // Unstable assertion: assertSame(tracer_ThreadTrace2, tracer_ThreadTrace0);
      //  // Unstable assertion: assertNotNull(tracer_ThreadTrace2);
      //  // Unstable assertion: assertFalse(tracer_ThreadTrace2.equals((Object)tracer_ThreadTrace1));
      
      tracer_ThreadTrace2.init();
      //  // Unstable assertion: assertNotSame(tracer_ThreadTrace2, tracer_ThreadTrace1);
      //  // Unstable assertion: assertSame(tracer_ThreadTrace2, tracer_ThreadTrace0);
      //  // Unstable assertion: assertFalse(tracer_ThreadTrace2.equals((Object)tracer_ThreadTrace1));
      
      Tracer tracer1 = Tracer.shortName(tracer_ThreadTrace2, string0);
      //  // Unstable assertion: assertNotSame(tracer_ThreadTrace2, tracer_ThreadTrace1);
      //  // Unstable assertion: assertSame(tracer_ThreadTrace2, tracer_ThreadTrace0);
      //  // Unstable assertion: assertNotSame(tracer1, tracer0);
      //  // Unstable assertion: assertNotNull(tracer1);
      //  // Unstable assertion: assertFalse(tracer_ThreadTrace2.equals((Object)tracer_ThreadTrace1));
      //  // Unstable assertion: assertFalse(tracer1.equals((Object)tracer0));
      
      String string1 = Tracer.getCurrentThreadTraceReport();
      //  // Unstable assertion: assertNotSame(string1, string0);
      //  // Unstable assertion: assertEquals("      21.320 Start        [ThreadTrace] /-*mw_K_9n\\\n    0 21.320 Start        [ThreadTrace] /-*mw_K_9n\\\n Unstopped timers:\n  [ThreadTrace] /-*mw_K_9n\\ (0 ms, started at 21.320)\n  [ThreadTrace] /-*mw_K_9n\\ (0 ms, started at 21.320)\n", string1);
      //  // Unstable assertion: assertNotNull(string1);
      //  // Unstable assertion: assertFalse(string1.equals((Object)string0));
      
      int int0 = (-1);
      tracer_ThreadTrace2.endEvent(tracer0, int0);
      //  // Unstable assertion: assertNotSame(string0, string1);
      //  // Unstable assertion: assertNotSame(tracer_ThreadTrace2, tracer_ThreadTrace1);
      //  // Unstable assertion: assertSame(tracer_ThreadTrace2, tracer_ThreadTrace0);
      //  // Unstable assertion: assertNotSame(tracer_ThreadTrace0, tracer_ThreadTrace1);
      //  // Unstable assertion: assertSame(tracer_ThreadTrace0, tracer_ThreadTrace2);
      //  // Unstable assertion: assertNotSame(tracer0, tracer1);
      //  // Unstable assertion: assertFalse(string0.equals((Object)string1));
      //  // Unstable assertion: assertFalse(tracer_ThreadTrace2.equals((Object)tracer_ThreadTrace1));
      //  // Unstable assertion: assertFalse(tracer_ThreadTrace0.equals((Object)tracer_ThreadTrace1));
      //  // Unstable assertion: assertFalse(tracer0.equals((Object)tracer1));
      
      Map<String, Long> map0 = Tracer.getTypeToTimeMap();
      //  // Unstable assertion: assertNull(map0);
      
      String string2 = tracer0.toString();
      //  // Unstable assertion: assertNotSame(string0, string1);
      //  // Unstable assertion: assertNotSame(string0, string2);
      //  // Unstable assertion: assertNotSame(string2, string1);
      //  // Unstable assertion: assertNotSame(string2, string0);
      //  // Unstable assertion: assertNotSame(tracer_ThreadTrace0, tracer_ThreadTrace1);
      //  // Unstable assertion: assertSame(tracer_ThreadTrace0, tracer_ThreadTrace2);
      //  // Unstable assertion: assertNotSame(tracer0, tracer1);
      //  // Unstable assertion: assertEquals("[ThreadTrace] /-*mw_K_9n\\", string2);
      //  // Unstable assertion: assertNotNull(string2);
      //  // Unstable assertion: assertFalse(string0.equals((Object)string1));
      //  // Unstable assertion: assertFalse(string0.equals((Object)string2));
      //  // Unstable assertion: assertFalse(string2.equals((Object)string1));
      //  // Unstable assertion: assertFalse(string2.equals((Object)string0));
      //  // Unstable assertion: assertFalse(tracer_ThreadTrace0.equals((Object)tracer_ThreadTrace1));
      //  // Unstable assertion: assertFalse(tracer0.equals((Object)tracer1));
      
      tracer_ThreadTrace2.truncateEvents();
      //  // Unstable assertion: assertNotSame(tracer_ThreadTrace2, tracer_ThreadTrace1);
      //  // Unstable assertion: assertSame(tracer_ThreadTrace2, tracer_ThreadTrace0);
      //  // Unstable assertion: assertFalse(tracer_ThreadTrace2.equals((Object)tracer_ThreadTrace1));
      
      Tracer.clearTracingStatisticsTestingOnly();
      long long0 = tracer0.stop();
      //  // Unstable assertion: assertNotSame(string0, string1);
      //  // Unstable assertion: assertNotSame(string0, string2);
      //  // Unstable assertion: assertNotSame(tracer_ThreadTrace0, tracer_ThreadTrace1);
      //  // Unstable assertion: assertSame(tracer_ThreadTrace0, tracer_ThreadTrace2);
      //  // Unstable assertion: assertNotSame(tracer0, tracer1);
      //  // Unstable assertion: assertEquals(0L, long0);
      //  // Unstable assertion: assertFalse(string0.equals((Object)string1));
      //  // Unstable assertion: assertFalse(string0.equals((Object)string2));
      //  // Unstable assertion: assertFalse(tracer_ThreadTrace0.equals((Object)tracer_ThreadTrace1));
      //  // Unstable assertion: assertFalse(tracer0.equals((Object)tracer1));
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Tracer.ThreadTrace tracer_ThreadTrace0 = Tracer.getThreadTrace();
      assertNotNull(tracer_ThreadTrace0);
      
      String string0 = "/-*mw_K_9n\\";
      Tracer tracer0 = Tracer.shortName(tracer_ThreadTrace0, string0);
      assertNotNull(tracer0);
      
      Tracer.ThreadTrace tracer_ThreadTrace1 = new Tracer.ThreadTrace();
      assertNotSame(tracer_ThreadTrace1, tracer_ThreadTrace0);
      assertNotNull(tracer_ThreadTrace1);
      assertFalse(tracer_ThreadTrace1.equals((Object)tracer_ThreadTrace0));
      
      tracer_ThreadTrace1.truncateOutstandingEvents();
      assertNotSame(tracer_ThreadTrace1, tracer_ThreadTrace0);
      assertFalse(tracer_ThreadTrace1.equals((Object)tracer_ThreadTrace0));
      
      int int0 = (-1);
      // Undeclared exception!
      try {
        tracer_ThreadTrace1.endEvent(tracer0, int0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      String string0 = null;
      char[] charArray0 = new char[5];
      Tracer tracer0 = Tracer.shortName(string0, string0);
      assertNotNull(tracer0);
      
      Tracer.initCurrentThreadTrace(charArray0[4]);
      assertArrayEquals(new char[] {'\u0000', '\u0000', '\u0000', '\u0000', '\u0000'}, charArray0);
      
      // Undeclared exception!
      try {
        long long0 = tracer0.stop(charArray0[0]);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Tracer.enableTypeMaps();
      Map<String, Long> map0 = Tracer.getTypeToTimeMap();
      assertNotNull(map0);
      assertEquals(0, map0.size());
      assertEquals(true, map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Tracer.enableTypeMaps();
      Map<String, Long> map0 = Tracer.getTypeToSilentMap();
      assertNotNull(map0);
      assertEquals(0, map0.size());
      assertEquals(true, map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Map<String, Long> map0 = Tracer.getTypeToSilentMap();
      assertNull(map0);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Tracer.enableTypeMaps();
      Map<String, Long> map0 = Tracer.getTypeToCountMap();
      assertNotNull(map0);
      assertEquals(true, map0.isEmpty());
      assertEquals(0, map0.size());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Map<String, Long> map0 = Tracer.getTypeToCountMap();
      assertNull(map0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Tracer.enableTypeMaps();
      Tracer.enableTypeMaps();
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      String string0 = "Giant thread trace. Too many Tracers created. Clearing to avoid memory leak.";
      StringBuilder stringBuilder0 = new StringBuilder(string0);
      assertNotNull(stringBuilder0);
      assertEquals("Giant thread trace. Too many Tracers created. Clearing to avoid memory leak.", stringBuilder0.toString());
      
      int int0 = (-1653);
      Tracer.appendSpaces(stringBuilder0, int0);
      assertEquals("Giant thread trace. Too many Tracers created. Clearing to avoid memory leak.", stringBuilder0.toString());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      int int0 = 1778;
      StringBuilder stringBuilder0 = new StringBuilder(int0);
      assertNotNull(stringBuilder0);
      assertEquals("", stringBuilder0.toString());
      
      Tracer.appendSpaces(stringBuilder0, int0);
      assertEquals("                ", stringBuilder0.toString());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Tracer.clearCurrentThreadTrace();
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      boolean boolean0 = false;
      Tracer.setPrettyPrint(boolean0);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Tracer.logAndClearCurrentThreadTrace();
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Tracer.Stat tracer_Stat0 = new Tracer.Stat();
      assertNotNull(tracer_Stat0);
      
      int int0 = tracer_Stat0.getCount();
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      String string0 = null;
      Tracer.Stat tracer_Stat0 = Tracer.getStatsForType(string0);
      assertNotNull(tracer_Stat0);
      
      int int0 = tracer_Stat0.getSilentCount();
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Tracer.Stat tracer_Stat0 = new Tracer.Stat();
      assertNotNull(tracer_Stat0);
      
      int int0 = tracer_Stat0.getTotalTime();
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      char[] charArray0 = new char[5];
      Tracer.initCurrentThreadTrace(charArray0[0]);
      assertArrayEquals(new char[] {'\u0000', '\u0000', '\u0000', '\u0000', '\u0000'}, charArray0);
  }
}
